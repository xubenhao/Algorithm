//	Author : XuBenHao                                                  
//	Version : 1.0.0                 
//	Mail : xbh370970843@163.com
//	Copyright : XuBenHao 2020 - 2030 

#ifndef AILIB_DESIGN_GREEDY_CHARENCODE_H
#define AILIB_DESIGN_GREEDY_CHARENCODE_H
#include "..\..\stdafx.h"

// 问题：
// 给定字符集&给定字符集每个字符出现频率

// 目标：
// 设计一套适合此字符集的前缀码
// 要求：所设计的前缀码在所有可行前缀码中具备此前缀码存储所有字符占用空间最小的特点。

// 如何给字符集设计可行前缀码
// 二叉树每个叶子节点p
// 二叉树根节点r到p形成一条路径r->x1->...->xk->p
// 设路径上每条左向边代表0，右向边代表1
// 则r->x1->...->xk->p代表若干个0/1组成的一个编码
// 二叉树任意两个叶节点p1,p2
// 按上述规则确立p1,p2的编码
// 则可以保证p1,p2编码或许前面有重叠部分。
// 但不会存在完全重叠，或者一方覆盖另一方的问题。

// 则假设字符集有n个字符
// 我们选择一棵n个叶子节点的二叉树，
// 按上述规则对每个叶子节点编码，即可得到一套前缀码。

// 分析：
// 给定任意一套可行的前缀码
// 我们以此前缀码可以构造出一棵二叉树。二叉树中叶子节点代表一个字符。
// 给定任意一棵叶子节点个数为n的二叉树，我们按左边为0，右边为1方式，
// 每个叶子节点得到一个编码。
// 且此编码下，所有编码存在重叠部分，但相互间不会覆盖或完全重叠。
// 故，这样得到的是一套前缀码。

// 综合，前缀码和二叉树存在一一对应的关系。
// 我们求最优前缀码
// 也即求对应的最优二叉树

// 设每个叶子节点代表字符出现次数作为叶子节点权重
// 每个叶子节点代表字符编码长度为从根到该节点路径上边的个数
// 最优二叉树即，
// 具备n个叶子节点的二叉树，此n个叶子节点的 权重*根到该叶子节点的路径边数 总和最小。

// 任何具备n个叶子节点的二叉树，可以生成一套可行的适用于n个字符集的前缀码
// 这样的二叉树个数无限

// 故只需考察
// [从n个中选0个，从n个中选两个，从n个中选n3个，..., 从n个中选n/2个]
// 即使如此，按照选择并且利用较小规模求解的方式，还是因为选择太多，而造成，算法执行效率不高。

// 二叉树的频度 = 所有 二叉树中叶子节点频度 * 叶子节点在树中高度 之和
// 按照此定义
// 对只含叶子节点的子树，其频度为0
// 设某一时刻，二叉树由互不相交的子树k1,...,km构成
// 即任意两棵子树不包含重复的叶子节点，所有m棵子树叶子节点并集等于二叉树的节点集合。任意子树至少含一个叶子节点。
// 二叉树的频度 = 所有 子树频度+子树中叶子节点频度和 * 子树根节点在二叉树的高度 之和

// 初始时，
// n个叶子节点，构成n棵子树
// 我们证明，做出频度最小子树合并是构造最优二叉树必然选择

// 假设在最终最优二叉树，n个叶子节点高度分别为h1,...,hn
// 我们需要证明，频度最小两个叶子节点拥有最大高度
// 设拥有最大高度节点为x1,x2,其高度为h1,h2
// 设频度最小节点为y1,y2,其高度为h3,h4
// 若x1,x2不等于y1,y2
// 我们用y1,y2，替换x1,x2其他子树不动，将得到一个更优的二叉树。
// 故最优二叉树必然y1,y2为其高度最高两节点。

// 假设某次选择前，
// 二叉树已经形成的子树划分为k1,...,km
// 我们需要证明，频度最小的两个子树，用于最大的子树高度
// 设拥有最大高度子树节点为x1,x2,其高度为h1,h2
// 设频度最小子树节点为y1,y2,其高度为h3,h4
// 若x1,x2不等于y1,y2
// 我们用y1,y2，替换x1,x2其他子树不动，将得到一个更优的二叉树。
// 故最优二叉树必然y1,y2为其高度最高两节点。

// 得证
#endif



